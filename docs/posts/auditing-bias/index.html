<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kusuma Kumar">
<meta name="dcterms.date" content="2025-05-07">
<meta name="description" content="A fairness audit of income prediction using U.S. Census data with folktables and logistic regression, with emphasis on gender and race group disparities.">

<title>Auditing Bias – My Awesome CSCI 0451 Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6de787833effe4777a6777a5e05fb578.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: white;
      }

      .quarto-title-block .quarto-title-banner {
        color: white;
background-image: url(../../img/landscape.png);
background-size: cover;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Awesome CSCI 0451 Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Auditing Bias</h1>
                  <div>
        <div class="description">
          A fairness audit of income prediction using U.S. Census data with folktables and logistic regression, with emphasis on gender and race group disparities.
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Kusuma Kumar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 7, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This blog presents a fairness audit of income prediction using U.S. Census data via the folktables library and logistic regression. Focusing on gender and racial disparities, we explore how predictive performance and outcome distributions vary across demographic groups in California. Through descriptive statistics, visualizations, and model auditing including disaggregated accuracy, predictive values, and error rates, we uncover systemic gaps, particularly the underrepresentation of women and racial minorities among high earners. These findings highlight both model bias and broader socioeconomic inequities reflected in the data.</p>
<p>Note: Some values may differ slightly as metrics vary every time model is created.</p>
<p>Accessing data using folktables:</p>
<div id="cell-2" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> folktables <span class="im">import</span> ACSDataSource, ACSEmployment, BasicProblem</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>STATE <span class="op">=</span> <span class="st">"CA"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>data_source <span class="op">=</span> ACSDataSource(survey_year<span class="op">=</span><span class="st">'2018'</span>, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                            horizon<span class="op">=</span><span class="st">'1-Year'</span>, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                            survey<span class="op">=</span><span class="st">'person'</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>acs_data <span class="op">=</span> data_source.get_data(states<span class="op">=</span>[STATE], download<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="pedicting-income" class="level1">
<h1>Pedicting income</h1>
<p>Feature descriptions: PINCP: Total person’s income (integers between -19997 and 4209995 income in US dollars) COW (Class of worker): Range of values AGEP: age in years, max. 99 SCHL: Educational attainment (categorical values 1-24, or NA) WKHP: usual hours worked per week past 12 months, max. 99 (or NA) SEX: Sex/Gender (1: Male / 2: Female) RAC1P: Recoded detailed race code (categorical values 1-9)</p>
<p>Subsetting relevent features from ACS PUMS data, focusing on the ACSIncome Task to predict whether a not an individual’s income is greater that $50k:</p>
<div id="cell-4" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>possible_features<span class="op">=</span>[<span class="st">'PINCP'</span>, <span class="st">'COW'</span>, <span class="st">'AGEP'</span>, <span class="st">'SCHL'</span>, <span class="st">'SEX'</span>, <span class="st">'WKHP'</span>, <span class="st">'RAC1P'</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>acs_data[possible_features]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">PINCP</th>
<th data-quarto-table-cell-role="th">COW</th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">SCHL</th>
<th data-quarto-table-cell-role="th">SEX</th>
<th data-quarto-table-cell-role="th">WKHP</th>
<th data-quarto-table-cell-role="th">RAC1P</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>48500.0</td>
<td>6.0</td>
<td>30</td>
<td>14.0</td>
<td>1</td>
<td>40.0</td>
<td>8</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>0.0</td>
<td>NaN</td>
<td>18</td>
<td>14.0</td>
<td>2</td>
<td>NaN</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>13100.0</td>
<td>NaN</td>
<td>69</td>
<td>17.0</td>
<td>1</td>
<td>NaN</td>
<td>9</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0.0</td>
<td>NaN</td>
<td>25</td>
<td>1.0</td>
<td>1</td>
<td>NaN</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>NaN</td>
<td>31</td>
<td>18.0</td>
<td>2</td>
<td>NaN</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">378812</td>
<td>2400.0</td>
<td>1.0</td>
<td>61</td>
<td>21.0</td>
<td>2</td>
<td>NaN</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">378813</td>
<td>30000.0</td>
<td>1.0</td>
<td>40</td>
<td>17.0</td>
<td>1</td>
<td>40.0</td>
<td>8</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">378814</td>
<td>0.0</td>
<td>NaN</td>
<td>43</td>
<td>16.0</td>
<td>2</td>
<td>NaN</td>
<td>8</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">378815</td>
<td>0.0</td>
<td>NaN</td>
<td>23</td>
<td>16.0</td>
<td>1</td>
<td>NaN</td>
<td>8</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">378816</td>
<td>0.0</td>
<td>NaN</td>
<td>18</td>
<td>14.0</td>
<td>1</td>
<td>NaN</td>
<td>8</td>
</tr>
</tbody>
</table>

<p>378817 rows × 7 columns</p>
</div>
</div>
</div>
<div id="cell-5" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>features_to_use <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> possible_features <span class="cf">if</span> f <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"PINCP"</span>, <span class="st">"SEX"</span>]]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>IncomeProblem <span class="op">=</span> BasicProblem(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    features<span class="op">=</span>features_to_use,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    target<span class="op">=</span><span class="st">'PINCP'</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    target_transform<span class="op">=</span><span class="kw">lambda</span> x: x<span class="op">&gt;</span><span class="dv">50000</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    group<span class="op">=</span><span class="st">'SEX'</span>,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    preprocess<span class="op">=</span><span class="kw">lambda</span> x: x,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    postprocess<span class="op">=</span><span class="kw">lambda</span> x: np.nan_to_num(x, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>features, label, group <span class="op">=</span> IncomeProblem.df_to_numpy(acs_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍result ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍is ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍now ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍a ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍feature ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍matrix ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍features, ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍a ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍label ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍vector ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍label, ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍and ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍a ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍group ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍label ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍vector ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍group, ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍in ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍convenient ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍format ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍with ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍which ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍we ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍can ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍work.</p>
<div id="cell-7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> obj <span class="kw">in</span> [features, label, group]:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(obj.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(378817, 5)
(378817,)
(378817,)</code></pre>
</div>
</div>
</section>
<section id="basic-descriptive" class="level1">
<h1>Basic Descriptive</h1>
<p>Before ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍we ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍touch ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍the ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍data ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍any ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍more, ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍we ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍should ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍perform ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍a ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍train-test ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍split. Then ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍create ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍a ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍model ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍and ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍train ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍it ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍on ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍the ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍training ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍data. Then turn ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍training ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍data into a data frame for easier analysis. We then add two additional columns: “group”, which stores the grouping information from group_train, and “label”, which contains the target values from y_train. Finally, it displays the first 5 rows of the DataFrame using df.head(), allowing a quick preview of the data, including both the features and the associated group and label information.</p>
<div id="cell-9" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test, group_train, group_test <span class="op">=</span> train_test_split(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    features, label, group, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(X_train, columns <span class="op">=</span> features_to_use)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"group"</span>] <span class="op">=</span> group_train</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"label"</span>] <span class="op">=</span> y_train</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">COW</th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">SCHL</th>
<th data-quarto-table-cell-role="th">WKHP</th>
<th data-quarto-table-cell-role="th">RAC1P</th>
<th data-quarto-table-cell-role="th">group</th>
<th data-quarto-table-cell-role="th">label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>7.0</td>
<td>77.0</td>
<td>16.0</td>
<td>40.0</td>
<td>1.0</td>
<td>2</td>
<td>True</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1.0</td>
<td>29.0</td>
<td>20.0</td>
<td>40.0</td>
<td>6.0</td>
<td>1</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>0.0</td>
<td>60.0</td>
<td>21.0</td>
<td>0.0</td>
<td>1.0</td>
<td>2</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>3.0</td>
<td>27.0</td>
<td>19.0</td>
<td>16.0</td>
<td>1.0</td>
<td>2</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>63.0</td>
<td>23.0</td>
<td>0.0</td>
<td>1.0</td>
<td>1</td>
<td>True</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Keeping in mind: SEX ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍is ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍binary ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍(1 ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍for ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍male, ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍2 ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍for ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍female). I applied these values to the group to find the following counts.</p>
<p>We first prints the total number of individuals in the dataset using df.shape[0], followed by the number of females and males, which are determined by checking how many entries in the group column are labeled as 2 (females) and 1 (males), respectively. Then we filter the data to include only individuals who have a label of 1 (presumably indicating a high-income group, such as earning over $50K) and focuses on the group and label columns. After filtering, we prints the number of individuals earning over $50K, as well as the number of females and males within that group. The output shows that there are 303,053 individuals in total, with a near-even distribution between females (153,759) and males (149,294). Among the high-income earners, there are 73,963 individuals, with 29,917 females and 44,046 males, indicating a higher proportion of males earning above $50K.</p>
<div id="cell-11" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of individuals in the data: </span><span class="sc">{</span>df<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of females in the data: </span><span class="sc">{</span>(df[<span class="st">'group'</span>] <span class="op">==</span> <span class="dv">2</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of males in the data: </span><span class="sc">{</span>(df[<span class="st">'group'</span>] <span class="op">==</span> <span class="dv">1</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>relevant_cols <span class="op">=</span> [<span class="st">'group'</span>, <span class="st">'label'</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df[df[<span class="st">'label'</span>] <span class="op">==</span> <span class="dv">1</span>][relevant_cols]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of individuals earning over ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: </span><span class="sc">{</span>df_filtered<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of females earning above ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: </span><span class="sc">{</span>(df_filtered[<span class="st">'group'</span>] <span class="op">==</span> <span class="dv">2</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of males earning above ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: </span><span class="sc">{</span>(df_filtered[<span class="st">'group'</span>] <span class="op">==</span> <span class="dv">1</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of individuals in the data: 303053
Number of females in the data: 153759
Number of males in the data: 149294
Number of individuals earning over ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: 73963
Number of females earning above ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: 29917
Number of males earning above ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍$50K: 44046</code></pre>
</div>
</div>
<section id="figure-1" class="level2">
<h2 class="anchored" data-anchor-id="figure-1">Figure 1</h2>
<p>Race 1, the largest racial group in the dataset ( “White”), dominates in both income categories, with the highest number of individuals in each bracket. Within this group, males outnumber females in the higher income bracket (&gt;$50K), while females outnumber males in the lower income bracket (≤$50K). Race 2,representing “Black” or “African American,” is the second largest group and shows a similar trend: females are more numerous in the lower income bracket, while males outnumber females among those earning above $50K. Smaller racial groups (such as those labeled 6, 7, 8, and 9) have much lower representation and tend to have a more balanced gender distribution, with a slight male predominance in higher income brackets. Across nearly all racial groups, males are more likely to be in the higher income bracket, while females are more prevalent in the lower bracket. Overall, a visible gender gap exists in higher income brackets, with males more represented among higher earners. Race 1’s dominance in both high and low income brackets may reflect population distribution or socioeconomic disparities, while smaller racial groups have minimal representation in both categories.</p>
<div id="cell-13" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>df_values <span class="op">=</span> df[[<span class="st">"label"</span>, <span class="st">"RAC1P"</span>, <span class="st">"group"</span>]].copy()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>df_values[<span class="st">"label"</span>] <span class="op">=</span> df_values[<span class="st">"label"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x:  <span class="st">"&gt; $50K"</span> <span class="cf">if</span> x <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span>  <span class="st">"&lt;= $50K"</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>df_values[<span class="st">"Sex"</span>] <span class="op">=</span> df_values[<span class="st">"group"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x:  <span class="st">"Male"</span> <span class="cf">if</span> x <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span>  <span class="st">"Female"</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>fig1 <span class="op">=</span> sns.catplot(data <span class="op">=</span> df_values, </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> <span class="st">"RAC1P"</span>, </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                hue <span class="op">=</span> <span class="st">"Sex"</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                col<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                kind<span class="op">=</span><span class="st">"count"</span>,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                palette<span class="op">=</span><span class="st">"deep"</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>fig1.set_axis_labels(<span class="st">"Race"</span>, <span class="st">"Count of indvidual within label earnings"</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Focusing on the column with label &lt; 50k, there is a clear trend indicating that, across all racial groups, a higher number of females earn less than $50K compared to males. In the income category above $50K, White males(race 1) are significantly overrepresented relative to females, suggesting a notable gender disparity. Among Black or African American individuals, there were slighly more females that males earning above $50K. For Asian and Other racial groups, males also tend to earn more, though the disparity is less pronounced. Earnings appear to be relatively balanced between genders among individuals identifying with two or more races(race 9).</p>
</section>
<section id="figure-2" class="level2">
<h2 class="anchored" data-anchor-id="figure-2">Figure 2</h2>
<p>The code begins by extracting and duplicating key columns (AGEP, PINCP, SEX, and RAC1P) from the original dataset for analysis. The SEX column is mapped to descriptive gender labels (“Male” or “Female”), while the RAC1P column is recoded to more interpretable race categories (e.g., “White”, “Asian”, “Black or African American”). Using Seaborn’s FacetGrid, the code creates a series of scatter plots showing the relationship between age (AGEP) and income (PINCP), with each subplot representing a different racial group. Data points are colored and styled by gender to facilitate comparison. Axis labels, legends, and titles are added for clarity, and the entire visualization is titled to reflect the focus on age-income patterns across race and gender.</p>
<div id="cell-15" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df_fig_2 <span class="op">=</span> acs_data[[<span class="st">"AGEP"</span>, <span class="st">"PINCP"</span>, <span class="st">"SEX"</span>, <span class="st">"RAC1P"</span>]].copy()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>df_fig_2[<span class="st">"Sex"</span>] <span class="op">=</span> df_fig_2[<span class="st">"SEX"</span>].<span class="bu">map</span>({<span class="dv">1</span>: <span class="st">"Male"</span>, <span class="dv">2</span>: <span class="st">"Female"</span>})</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>race_map <span class="op">=</span> {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"White"</span>,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"Black or African American"</span>,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"American Indian"</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"Alaska Native"</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"American Indian/Alaska Native NOS"</span>,</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"Asian"</span>,</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: <span class="st">"NH/Other Pacific Islander"</span>,</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="dv">8</span>: <span class="st">"Other"</span>,</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="dv">9</span>: <span class="st">"Two or More"</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>df_fig_2[<span class="st">"Race"</span>] <span class="op">=</span> df_fig_2[<span class="st">"RAC1P"</span>].<span class="bu">map</span>(race_map)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.FacetGrid(df_fig_2, col<span class="op">=</span><span class="st">"Race"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>g.map_dataframe(sns.scatterplot, x<span class="op">=</span><span class="st">"AGEP"</span>, y<span class="op">=</span><span class="st">"PINCP"</span>, hue<span class="op">=</span><span class="st">"Sex"</span>, style<span class="op">=</span><span class="st">"Sex"</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>g.set_axis_labels(<span class="st">"Age"</span>, <span class="st">"Income (PINCP)"</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>g.add_legend(title<span class="op">=</span><span class="st">"Gender"</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>g.set_titles(col_template<span class="op">=</span><span class="st">"Race: </span><span class="sc">{col_name}</span><span class="st">"</span>)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(top<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>g.fig.suptitle(<span class="st">"Scatter Plot of Age vs Income Faceted by Race and Colored by Gender"</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-9-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The income distribution across all races is highly skewed, with the majority of individuals earning lower incomes and a smaller group earning significantly higher amounts. There is no clear linear relationship between age and income, as the income distribution is widely dispersed across ages, although higher incomes tend to be more common in middle-aged groups.</p>
<p>Looking at race-specific trends, White individuals exhibit the broadest spread in both age and income, with a noticeable concentration of high-income outliers above $600,000. Males and females are represented across the income range, though high-income outliers are more prominent in this group. For Asians, while there are some high-income outliers, most incomes remain below $400,000, and the gender distribution among higher earners is relatively balanced. Black or African American individuals tend to have incomes below $200,000, with fewer high-income outliers compared to Whites and Asians. The gender distribution within this group is fairly even. Those identifying as Two or More Races or Other also exhibit lower income levels, with most incomes below $200,000 and a few outliers, though their sample sizes are smaller and the distribution is less pronounced. American Indian, Alaska Native, and NH/Other Pacific Islander groups have the lowest income ranges and smallest sample sizes, with very few individuals earning above $100,000.</p>
<p>In terms of gender patterns, both males and females are represented across the income spectrum in most racial categories, although there does not appear to be a consistent gender gap in income within each group. However, in both the White and Asian groups, higher earners are more often male. As for age trends, higher incomes are predominantly seen among individuals aged 30 to 60, with fewer high-income earners at younger or older ages. There is no strong evidence suggesting that income consistently increases with age, but income tends to be more variable among middle-aged individuals. The sample size also plays a role, with White individuals making up the largest group, followed by Asians and Black or African Americans. Smaller sample sizes in other racial categories make it difficult to observe clear trends.</p>
</section>
</section>
<section id="training-model" class="level1">
<h1>Training Model</h1>
<p>The following code leverages a Pipeline to streamline the process of feature engineering, scaling, and model training for logistic regression. The pipeline first applies polynomial feature expansion (degree 2) to capture non-linear relationships, followed by standard scaling to ensure that all features are on a comparable scale. The logistic regression model is then trained with a focus on finding the best regularization parameter (C) and polynomial degree through GridSearchCV, trying to implement two of the suggested approaches. The best model configuration, found through grid search, achieves a mean accuracy of 0.842 with a polynomial degree of 3 and a regularization parameter C of 1000. This approach automates the optimization of both the feature transformation and model hyperparameters, ensuring the most effective model is selected based on cross-validation performance.</p>
<div id="cell-17" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inspo from https://www.geeksforgeeks.org/logistic-regression-with-polynomial-features/ </span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, accuracy_score</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline <span class="co"># So I dont have to manually create different models</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> GridSearchCV</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>pipeline <span class="op">=</span> Pipeline([</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'poly'</span>, PolynomialFeatures(degree<span class="op">=</span><span class="dv">2</span>)), </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'scaler'</span>, StandardScaler()), </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'logistic'</span>, LogisticRegression(max_iter<span class="op">=</span><span class="dv">1000</span>))</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>param_grid <span class="op">=</span> {</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'poly__degree'</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'logistic__C'</span>: [<span class="fl">0.001</span>, <span class="fl">0.01</span>, <span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1000</span>]</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>LR_search <span class="op">=</span> GridSearchCV(pipeline, param_grid<span class="op">=</span>param_grid, verbose <span class="op">=</span> <span class="dv">1</span>, cv<span class="op">=</span><span class="dv">5</span>, n_jobs <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>LR_search.fit(X_train , y_train)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>LR_search.best_params_</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Mean Accuracy: </span><span class="sc">{</span>LR_search<span class="sc">.</span>best_score_<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Config: </span><span class="sc">{</span>LR_search<span class="sc">.</span>best_params_<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Fitting 5 folds for each of 21 candidates, totalling 105 fits
Mean Accuracy: 0.852
Config: {'logistic__C': 1000, 'poly__degree': 3}</code></pre>
</div>
</div>
</section>
<section id="auditing-model" class="level1">
<h1>Auditing Model</h1>
<section id="overall-measures" class="level2">
<h2 class="anchored" data-anchor-id="overall-measures">Overall Measures</h2>
<p>The following code evaluates the performance of a logistic regression model by calculating key metrics such as test accuracy, confusion matrix, and derived metrics including Predictive Positive Value (PPV), False Positive Rate (FPR), and False Negative Rate (FNR). It first computes the accuracy by comparing the true labels (y_test) with the predicted labels (y_pred). The confusion matrix is then used to derive four values: true negatives, false positives, false negatives, and true positives, which are used to calculate PPV (the proportion of positive predictions that are correct), FPR (the rate at which negative samples are misclassified as positive), and FNR (the rate at which positive samples are misclassified as negative). The output shows an accuracy of 85.4%, with a PPV of 72.6%, FPR of 7.7%, and FNR of 36.1%, highlighting the model’s strengths in predicting negatives correctly, but also revealing areas for improvement in minimizing false negatives.</p>
<div id="cell-19" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> LR_search.predict(X_test)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Metrics:"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_metrics(y_true, y_pred, group_name<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> group_name <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Metrics for Males:"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> group_name <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Metrics for Females:"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    test_accuracy <span class="op">=</span> accuracy_score(y_true, y_pred)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Test Accuracy: </span><span class="sc">{</span>test_accuracy<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(y_true, y_pred, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Confusion Matrix:"</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(cm)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    tn, fp, fn, tp <span class="op">=</span> cm.ravel()</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    PPV <span class="op">=</span> tp <span class="op">/</span> (tp <span class="op">+</span> fp)  </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    FPR <span class="op">=</span> fp <span class="op">/</span> (fp <span class="op">+</span> tn)  </span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    FNR <span class="op">=</span> fn <span class="op">/</span> (tp <span class="op">+</span> fn) </span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Predictive Value (PPV): </span><span class="sc">{</span>PPV<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"False Positive Rate (FPR): </span><span class="sc">{</span>FPR<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"False Negative Rate (FNR): </span><span class="sc">{</span>FNR<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>evaluate_metrics(y_test, y_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Overall Metrics:
Test Accuracy: 0.854
Confusion Matrix:
[[52928  4437]
 [ 6651 11748]]
Predictive Value (PPV): 0.726
False Positive Rate (FPR): 0.077
False Negative Rate (FNR): 0.361</code></pre>
</div>
</div>
</section>
<section id="by-group-measures" class="level2">
<h2 class="anchored" data-anchor-id="by-group-measures">By-Group Measures</h2>
<p>We then evaluate the performance of this logistic regression model for both males and females separately by calculating key metrics again such as test accuracy, confusion matrix, and derived metrics like Predictive Positive Value (PPV), False Positive Rate (FPR), and False Negative Rate (FNR). It first computes the accuracy for each gender by comparing the true labels (y_test) with the predicted labels (y_pred). The confusion matrix for each group provides the counts of true negatives, false positives, false negatives, and true positives, which are then used to calculate PPV (the accuracy of positive predictions), FPR (the rate of misclassifying negatives as positives), and FNR (the rate of misclassifying positives as negatives). For males, the accuracy is 83.6%, with a PPV of 77.2%, FPR of 7.8%, and FNR of 36.7%. For females, the accuracy is higher at 87.0%, with a PPV of 66.8%, FPR of 7.6%, and FNR of 35.3%. These results show that the model performs better for females, with higher accuracy and slightly better FPR, but both genders show similar FNR values, indicating opportunities for improving the model’s handling of false negatives.</p>
<div id="cell-21" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># There can be cases where testing set only containy one group</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> np.unique(group_test)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> group <span class="kw">in</span> groups:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    y_label_group <span class="op">=</span> y_test[group_test <span class="op">==</span> group]</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    y_pred_group <span class="op">=</span> y_pred[group_test <span class="op">==</span> group]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    evaluate_metrics(y_label_group, y_pred_group, group)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Metrics for Males:
Test Accuracy: 0.836
Confusion Matrix:
[[24281  2067]
 [ 4050  6985]]
Predictive Value (PPV): 0.772
False Positive Rate (FPR): 0.078
False Negative Rate (FNR): 0.367

Metrics for Females:
Test Accuracy: 0.870
Confusion Matrix:
[[28647  2370]
 [ 2601  4763]]
Predictive Value (PPV): 0.668
False Positive Rate (FPR): 0.076
False Negative Rate (FNR): 0.353</code></pre>
</div>
</div>
</section>
<section id="bias-measures" class="level2">
<h2 class="anchored" data-anchor-id="bias-measures">Bias Measures</h2>
<p>This following code generates calibration plots to assess how well the predicted probabilities from a model align with the actual outcomes, both overall and for specific subgroups. It first calculates the calibration curve for the entire dataset, comparing the predicted probabilities against the true positive rates, and visualizes it alongside a perfectly calibrated line.</p>
<div id="cell-24" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.calibration <span class="im">import</span> calibration_curve</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>prob_true, prob_pred <span class="op">=</span> calibration_curve(y_test, y_pred, n_bins<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>plt.plot(prob_pred, prob_true, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'Model'</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>plt.plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>], linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Perfectly Calibrated'</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Mean Predicted Probability'</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Fraction of True Positives'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Calibration Plot Overall (Reliability Diagram)'</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The function plot_calibration_by_group extends this analysis by plotting calibration curves for each subgroup within the dataset, allowing for a detailed comparison of how well the model is calibrated across different groups.</p>
<div id="cell-26" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_calibration_by_group(y_test, y_pred, group_test, groups):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> group <span class="kw">in</span> groups:</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        y_test_group <span class="op">=</span> y_test[group_test <span class="op">==</span> group]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        y_pred_group <span class="op">=</span> y_pred[group_test <span class="op">==</span> group]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        prob_true, prob_pred <span class="op">=</span> calibration_curve(y_test_group, y_pred_group, n_bins<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        plt.plot(prob_pred, prob_true, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="ss">f'Group </span><span class="sc">{</span>group<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    plt.plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>], linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Perfectly Calibrated'</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Mean Predicted Probability'</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Fraction of True Positives'</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Calibration Plot by Group (Reliability Diagram)'</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> np.unique(group_test)  </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the function to plot calibration curves for each group</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>plot_calibration_by_group(y_test, y_pred, group_test, groups)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="calibration-observations" class="level1">
<h1>Calibration observations</h1>
<p>The model is not well-calibrated, as indicated by the significant deviation from the diagonal line labeled “Perfectly Calibrated” in both the overall and group-specific calibration plots. In the overall calibration plot, the model’s predictions deviate notably from the ideal calibration line. At low probability ranges (below ~0.3), the model is underconfident, as shown by the curve above the diagonal, while at high probability ranges (above ~0.3), the model is overconfident, with the curve falling below the diagonal. When the model predicts a 100% probability, the actual fraction of true positives is only about 70%, further illustrating this miscalibration. The group-specific calibration plot reinforces these findings, as both Group 1 and Group 2 show considerable deviation from perfect calibration, with Group 2 displaying more severe overconfidence than Group 1. Neither group’s calibration curve approximates the ideal diagonal, confirming that the model’s probability estimates do not reliably correspond to actual outcomes.</p>
<div id="cell-28" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> group <span class="kw">in</span> groups:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    y_test_group <span class="op">=</span> y_test[group_test <span class="op">==</span> group]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    y_pred_group <span class="op">=</span> y_pred[group_test <span class="op">==</span> group]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    tn, fp, fn, tp <span class="op">=</span> confusion_matrix(y_test_group, y_pred_group).ravel()</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    TPR <span class="op">=</span> tp <span class="op">/</span> (tp <span class="op">+</span> fn)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    FPR <span class="op">=</span> fp <span class="op">/</span> (fp <span class="op">+</span> tn)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Group </span><span class="sc">{</span>group<span class="sc">}</span><span class="ss"> -- TPR: </span><span class="sc">{</span>TPR<span class="sc">:.3f}</span><span class="ss">, FPR: </span><span class="sc">{</span>FPR<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Group 1 -- TPR: 0.633, FPR: 0.078
Group 2 -- TPR: 0.647, FPR: 0.076</code></pre>
</div>
</div>
</section>
<section id="error-rate-balance" class="level1">
<h1>Error rate balance</h1>
<p>Key observations reveal a significant issue with the model’s error rates across two groups. While both groups exhibit identical false positive rates (FPR) of 0.082, there is a notable disparity in false negative rates (FNR). Group 1 experiences a 13% higher FNR compared to Group 2, with values of 0.407 and 0.359, respectively. This 0.048 difference in FNR violates the error rate balance requirement, which stipulates that models should have equal true positive rates (TPR) and false positive rates (FPR) across groups. Although the model maintains FPR equality, the discrepancy in FNR means that Group 1 is subjected to more missed positives (false negatives), while Group 2 benefits from better detection of true positives. This imbalance results in predictive inequality between the two groups. While the model might appear to perform well in certain metrics, the FNR disparity signals a failure to meet fairness standards, emphasizing the importance of error rate balance for equitable model predictions.</p>
<div id="cell-30" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>overall_positive_rate <span class="op">=</span> np.mean(y_pred)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Overall Predicted Positive Rate: </span><span class="sc">{</span>overall_positive_rate<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g <span class="kw">in</span> groups:</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> (group_test <span class="op">==</span> g)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    group_positive_rate <span class="op">=</span> np.mean(y_pred[idx])</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Group </span><span class="sc">{</span>g<span class="sc">}</span><span class="ss"> Predicted Positive Rate: </span><span class="sc">{</span>group_positive_rate<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Overall Predicted Positive Rate: 0.214
Group 1 Predicted Positive Rate: 0.242
Group 2 Predicted Positive Rate: 0.186</code></pre>
</div>
</div>
</section>
<section id="statistical-parity" class="level1">
<h1>Statistical Parity</h1>
<p>Based on the output of the code, the model does not satisfy statistical parity. Statistical parity requires that the predicted positive rate be equal across different groups. The overall predicted positive rate is 0.215, but the rates for each group are different: Group 1 has a predicted positive rate of 0.234, while Group 2 has a predicted positive rate of 0.198. These discrepancies indicate that the model is not equally distributing positive predictions across the groups, with Group 1 receiving a higher predicted positive rate than Group 2. As a result, the model fails to meet the statistical parity criterias, which would require these rates to be the same across all groups.</p>
</section>
<section id="figure-5-in-chouldechova" class="level1">
<h1>Figure ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍5 ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍in ‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍Chouldechova</h1>
<p>Not attempted as I am only trying to get an M on this blog post</p>
</section>
<section id="concluding-discussion" class="level1">
<h1>Concluding Discussion</h1>
<p>This commercially valuable to companies in financial services, recruitment, marketing, and insurance. For example, credit card issuers or loan providers might use the model to prescreen applicants for premium products. Recruitment platforms could use it to prioritize job candidates for high paying roles if income is seen as a proxy for experience or qualifications. Since salary information is open to the public in California, HR Departments of compaies in CA could make use of our model to support salary adjustments to close this gender pay gap. Additionally, marketers and service providers might use it to better understand customer profiles and tailor offerings, potentially improving access to relevant products and opportunities for underrepresented or underserved populations.</p>
<p>The model’s underconfidence at low probabilities and overconfidence at high probabilities means decisions made at extreme prediction levels may be inaccurate. For instance, if the model predicts a 100% probability for loan approval but only 70% of those cases are actually approved, applicants might be unfairly denied funding. Similarly, underconfident predictions could deny benefits to individuals who qualify, like in government welfare systems. The model also shows different predicted positive rates for the two groups: Males:0.234 and Females 0.198. This imbalance results in one males being favored over another, leading to unequal opportunities. For example, in hiring males are likely to receive higher rates of approvals, while females would face unjust rejection rates. The model exhibits discriminatory bias due to unequal prediction rates and error rate imbalances between groups. These biases, if left unchecked, could lead to systemic inequalities, continuing to propagate these biases by reinforcing existing disparities in predictions and outcomes.</p>
<p>It’s important to evaluate these bias across a broader range of features, including gender identities beyond just male and female which arent represented in this dataset. I believe significantly more testing and experimentation is necessary before this model can be responsibly deployed for larger-scale prediction tasks. I would start by incorporating datasets that account for these increasing gender idetities and also keeping this code and data open source so that more viewever are able to identify issues that stem from their background that me and other data scientists/ engineers can become oblivious to.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>